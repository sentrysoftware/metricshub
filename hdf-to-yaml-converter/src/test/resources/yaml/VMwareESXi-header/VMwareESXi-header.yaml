---
monitors:
  enclosure:
    discovery:
      sources:
        source(1):
          # Source(1) CIM_ComputerSystem class
          type: wbem
          namespace: root/cimv2
          query: "SELECT Manufacturer,Model,SerialNumber FROM CIM_Chassis"
          computes:
          # Add a Fake ID to our table so we can join it with Source(2)
          - type: leftConcat
            column: 1
            value: MSHW_TableID;
        source(2):
          # Source(2) CIM_Chassis to get the manufacturer
          type: wbem
          namespace: root/cimv2
          query: "SELECT BaseUnits,CurrentReading FROM CIM_NumericSensor"
          computes:
            # Keep only lines with units of type 7 (Watts)
            # ..hoping that there is only one power sensor per server.
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 7
          # Add a Fake ID to our table so we can join it with Source(1)
          - type: leftConcat
            column: 1
            value: MSHW_TableID;
        source(3):
          # Joint the tables to have
          # MSHW_TableID;Manufacturer;Model;SerialNumber;MSHW_TableID;BaseUnits;PowerConsumption;
          type: tableJoin
          leftTable: "${source::monitors.enclosure.discovery.sources.source(1)}"
          rightTable: "${source::monitors.enclosure.discovery.sources.source(2)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
          defaultRightLine: ;;;
        source(4):
          # VMWare sometimes returns more than one, often duplicate, enclosures  Will Table Joint to ensure only one is returned.  This procedure is only necessary for the PM.
          # MSHW_TableID;Manufacturer;Model;SerialNumber;MSHW_TableID;BaseUnits;PowerConsumption;UniqueID;
          type: tableJoin
          leftTable: MSHW_TableID;
          rightTable: "${source::monitors.enclosure.discovery.sources.source(3)}"
          leftKeyColumn: 1
          rightKeyColumn: 1
        source(5):
          # Make a copy of the discovery in the enclosure section
          type: copy
          from: "${source::monitors.memory.discovery.sources.source(6)}"
      mapping:
        # InstanceTable = Source(1)
        # MSHW_TableID;MSHW_TableID;Manufacturer;Model;SerialNumber;MSHW_TableID;BaseUnits;PowerConsumption;
        source: "${source::monitors.enclosure.discovery.sources.source(4)}"
        attributes:
          id: ESX4iServer
          model: $4
          serial_number: $5
          vendor: $3
          type: Computer
          name: "${awk::sprintf(\"Computer: (%s %s)\", $3, $4)}"
    collect:
      type: multiInstance
      sources:
        source(1):
          # 
          type: wbem
          namespace: root/cimv2
          query: "SELECT BaseUnits,CurrentReading FROM CIM_NumericSensor"
          computes:
            # Keep only lines with units of type 7 (Watts)
            # ..hoping that there is only one power sensor per server.
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 7
          # Divide by 100
          - type: divide
            column: 2
            value: 100
      mapping:
        source: "${source::monitors.enclosure.collect.sources.source(1)}"
        deviceId: ESX4iServer
        metrics:
          hw.enclosure.power: $2
          hw.enclosure.energy: fakeCounter($2)
  cpu:
    discovery:
      sources:
        source(1):
          # Caption,CurrentClockSpeed,HealthState,ModelName,DeviceID
          type: wbem
          query: "SELECT Caption,CurrentClockSpeed,HealthState,ModelName,DeviceID FROM CIM_Processor"
          namespace: root/cimv2
          computes:
            # Keep only lines with a valid HealthState
            # Caption,CurrentClockSpeed,HealthState,ModelName,DeviceID
          - type: keepOnlyMatchingLines
            column: 3
            valueList: "5,15,20,25,30"
      mapping:
        # InstanceTable = Source(1)
        # Caption,CurrentClockSpeed,HealthState,ModelName,DeviceID
        source: "${source::monitors.cpu.discovery.sources.source(1)}"
        attributes:
          id: $5
          __display_id: $1
          model: $4
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s - %s)\", $1, $4, megaHertz2HumanFormat($2))}"
        metrics:
          hw.cpu.speed.limit{limit_type="max"}: megaHertz2Hertz($2)
    collect:
      type: multiInstance
      sources:
        source(1):
          # Caption,HealthState
          type: wbem
          query: "SELECT DeviceID,HealthState FROM CIM_Processor"
          namespace: root/cimv2
          computes:
          # Caption,HealthState,HealthState
          - type: duplicateColumn
            column: 2
          # Caption,PatrolStatus,HealthState
          - type: translate
            column: 2
            translationTable: "${translation::statusTranslationTable}"
          # Caption,PatrolStatus,StatusInformation
          - type: translate
            column: 3
            translationTable: "${translation::statusInformationTranslationTable}"
      mapping:
        source: "${source::monitors.cpu.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="cpu"}: $2
        legacyTextParameters:
          StatusInformation: $3
  memory:
    discovery:
      sources:
        source(1):
          # Source (1)
          # Get a list of discrete sensors
          # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name
          type: wbem
          query: "SELECT MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,CurrentState,DeviceID,SensorType FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Add the NumericOnly Flag
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,NumericOnly,CurrentState,DeviceID,SensorType
          - type: rightConcat
            column: 5
            value: ;0
        source(2):
          # Source (2)
          # Get a list of numeric sensors (these are errorcounts, so we don't want the number only the status)
          # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,CurrentState,DeviceID
          type: wbem
          query: "SELECT MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,CurrentState,DeviceID,SensorType FROM OMC_NumericSensor"
          namespace: root/cimv2
          computes:
            # Add the NumericOnly Flag
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,NumericOnly,CurrentState,DeviceID,SensorType
          - type: rightConcat
            column: 5
            value: ;1
        source(3):
          # Union the Discrete and Numeric Sensors
          # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,NumericOnly,CurrentState,DeviceID,SensorType
          type: tableUnion
          tables:
          - "${source::monitors.memory.discovery.sources.source(1)}"
          - "${source::monitors.memory.discovery.sources.source(2)}"
          computes:
            # Keep Only Memory Sensors
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,NumericOnly,CurrentState,DeviceID,SensorType
          - type: keepOnlyMatchingLines
            column: 4
            valueList: 12
            # Process the discrete sensors to take worse Status and make each ID unique
            # DeviceID,HealthState,Name,NumericOnly
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,4,5,6"
        source(4):
          # Source (4)
          # Get a the overall memory status
          # HealthState
          type: wbem
          query: SELECT HealthState FROM OMC_Memory
          namespace: root/cimv2
          computes:
            # Add the Global ID
            # DeviceID,HealthState
          - type: leftConcat
            column: 1
            value: Global;
            # Add the Global Name and the NumericOnly Column
            # DeviceID,HealthState,Name,NumericOnly
          - type: rightConcat
            column: 2
            value: ;Global;0
        source(5):
          # Get a copy of the last memory discovery.  This was stored under Enclosure 7
          # DeviceID,HealthState,Tag,ElementName,Size
          type: copy
          from: "${source::monitors.enclosure.discovery.sources.source(5)}"
          computes:
            # Add OldInstance- to the Name
            # DeviceID,HealthState,Name,NumericOnly
          - type: leftConcat
            column: 3
            value: OldInstance-
            # Exclude OldInstance-Global as we're only interested in individual modules.
            # DeviceID,HealthState,Name,NumericOnly
          - type: excludeMatchingLines
            column: 3
            valueList: OldInstance-Global
            # Exclude NumericOnly Sensors as they can exist with Global
            # DeviceID,HealthState,Name,NumericOnly
          - type: excludeMatchingLines
            column: 4
            valueList: 1
        source(6):
          # Source (6) = Table Union of 4 (OMC_Memory) and 3 (IPMI) and 5 (Old Instance)
          # DeviceID,HealthState,Name,NumericOnly
          type: tableUnion
          tables:
          - "${source::monitors.memory.discovery.sources.source(3)}"
          - "${source::monitors.memory.discovery.sources.source(4)}"
          - "${source::monitors.memory.discovery.sources.source(5)}"
          computes:
            # Use an awk script to determine if there are any valid IPMI sensors, if not, use the global.
            # DeviceID,HealthState,Name,NumericOnly
          - type: awk
            script: "${file::embeddedFile-2}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4,5"
        source(7):
          # Make a copy of discovery 8 for use as the instance table.  Source(8) with its IPMIFound label will be passed to enclosure to be used at the next memory discovery.)
          # DeviceID,HealthState,Name,NumericOnly
          type: copy
          from: "${source::monitors.memory.discovery.sources.source(6)}"
          computes:
            # Exclude the ipmiFound line
            # DeviceID,HealthState,Name,NumericOnly
          - type: excludeMatchingLines
            column: 1
            valueList: ipmiFound
      mapping:
        # InstanceTable = Source(9)
        # DeviceID,HealthState,Name,NumericOnly
        source: "${source::monitors.memory.discovery.sources.source(7)}"
        attributes:
          id: $1
          __display_id: $3
          hw.parent.type: enclosure
          name: $3
    collect:
      type: multiInstance
      sources:
        source(1):
          # Source (1)
          # Get a list of discrete sensors
          # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,CurrentState,DeviceID
          type: wbem
          query: "SELECT MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,CurrentState,DeviceID FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Add a numeric sensor flag
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,NumericSensor,CurrentState,DeviceID
          - type: rightConcat
            column: 5
            value: ;0
        source(2):
          # Source (2)
          # Get a list of numeric sensors
          # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,CurrentState,DeviceID
          type: wbem
          query: "SELECT MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,CurrentState,DeviceID FROM OMC_NumericSensor"
          namespace: root/cimv2
          computes:
            # Add a numeric sensor flag
            # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,NumericSensor,CurrentState,DeviceID
          - type: rightConcat
            column: 4
            value: ;1
        source(3):
          # Union the Discrete and Numeric Sensors
          # MonitoredDeviceID,Caption,HealthState,IpmiSensorType,Name,NumericSensor,CurrentState,DeviceID
          type: tableUnion
          tables:
          - "${source::monitors.memory.collect.sources.source(1)}"
          - "${source::monitors.memory.collect.sources.source(2)}"
          computes:
            # Process the discrete sensors to take worse Status and make each ID unique
            # DeviceID,StatusInformation,HealthState
          - type: awk
            script: "${file::embeddedFile-1}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3,4"
            # Patrol Status comes from HealthState
            # MonitoredDeviceID,StatusInformation,HealthState
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
        source(4):
          # Get a the overall memory status
          # HealthState
          type: wbem
          query: SELECT HealthState FROM OMC_Memory
          namespace: root/cimv2
          computes:
            # Add the Global ID and an identifier for use in the AWK script
            # MonitoredDeviceID,HealthState
          - type: leftConcat
            column: 1
            value: Global;
            # Duplicate the Status Column
            # MonitoredDeviceID,HealthState,HealthState
          - type: duplicateColumn
            column: 2
            # Translate Status
            # MonitoredDeviceID,HealthState,PatrolStatus
          - type: translate
            column: 3
            translationTable: "${translation::statusTranslationTable}"
            # Translate Status Information
            # MonitoredDeviceID,StatusInformation,PatrolStatus
          - type: translate
            column: 2
            translationTable: "${translation::statusInformationTranslationTable}"
        source(5):
          # Union of Global and IPMI (4 & 3)
          # MonitoredDeviceID,StatusInformation,PatrolStatus
          type: tableUnion
          tables:
          - "${source::monitors.memory.collect.sources.source(3)}"
          - "${source::monitors.memory.collect.sources.source(4)}"
      mapping:
        # Instance Table
        # MonitoredDeviceID,StatusInformation,PatrolStatus
        source: "${source::monitors.memory.collect.sources.source(5)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="memory"}: $3
        legacyTextParameters:
          StatusInformation: $2
  power_supply:
    discovery:
      sources:
        source(1):
          # Caption,Availability,DeviceID
          type: wbem
          query: "SELECT Caption,Availability,DeviceID FROM CIM_PowerSupply"
          namespace: root/cimv2
          computes:
            # Keep only lines with a valid HealthState
            # Caption,Availability,DeviceID
            # 1 = Other, 2 = Unknown, 6 = Not Applicable, 11 = Not Installed
          - type: excludeMatchingLines
            column: 2
            valueList: "1,2,6,11"
      mapping:
        # InstanceTable = Source(1)
        # Caption,Availability,DeviceID
        source: "${source::monitors.power_supply.discovery.sources.source(1)}"
        attributes:
          id: $3
          __display_id: $1
          hw.parent.type: enclosure
          name: $1
    collect:
      type: multiInstance
      sources:
        source(1):
          # DeviceID,HealthState,Availability
          type: wbem
          query: "SELECT DeviceID,Healthstate,Availability FROM CIM_PowerSupply"
          namespace: root/cimv2
          computes:
            # Duplicate Availability
            # DeviceID,HealthState,Availability,Availability
          - type: duplicateColumn
            column: 3
            # Power Supply Patrol Status comes from HealthState
            # DeviceID,PatrolStatus,Availability,Availability
          - type: translate
            column: 2
            translationTable: "${translation::statusTranslationTable}"
            # Power Supply Information Status comes from Availability
            # DeviceID,PatrolStatus,StatusInformation,Availability
          - type: translate
            column: 3
            translationTable: "${translation::psuAvailabilityInformationTranslationTable}"
            # On some machines (namely Cisco Blades) the Health State Remains 0 (UNKNOWN) even if Availability clearly indicates a status
            # Translate the Availability into Patrol Status
            # DeviceID,PatrolStatus,StatusInformation,PatrolStatus(Availability)
          - type: translate
            column: 4
            translationTable: "${translation::psuAvailabilityTranslationTable}"
            # Exclude lines whose status is missing.  They will be picked up in the discovery as missing.
            # DeviceID,PatrolStatus,StatusInformation,PatrolStatus(Availability)
          - type: excludeMatchingLines
            column: 2
            valueList: MISSING
            # Let's add the availability status to the main Patrol Status and then take worse case
            # DeviceID,PatrolStatus,StatusInformation,PatrolStatus(Availability)
          - type: rightConcat
            column: 2
            value: '|'
          - type: rightConcat
            column: 2
            value: $4
          - type: convert
            column: 2
            conversion: array2SimpleStatus
      mapping:
        # Value Table
        # DeviceID,PatrolStatus,StatusInformation
        source: "${source::monitors.power_supply.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="power_supply"}: $2
        legacyTextParameters:
          StatusInformation: $3
  temperature:
    discovery:
      sources:
        source(1):
          # Source(1) Numeric Thermal Table
          # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical
          type: wbem
          query: "SELECT BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical FROM CIM_NumericSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 2 (Degree C)
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 2
            # Divide Thresholds by 100
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical
          - type: divide
            column: 6
            value: 100
          - type: divide
            column: 7
            value: 100
            # Remove Status of Unknown
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical
          - type: replace
            column: 5
            existingValue: 0
            newValue: ""
            # Thresholds for Temperature are sometimes reported as "0" by the agent.  Replacing these "0" by no value to prevent incorrect thresholds.
            # Add a MSHW_ string to our value and then remove MSHW_0. This should remove a 0 value and only that value
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical
          - type: leftConcat
            column: 6
            value: MSHW_
          - type: leftConcat
            column: 7
            value: MSHW_
          # Remove 0 value
          - type: replace
            column: 6
            existingValue: MSHW_0
            newValue: ""
          - type: replace
            column: 7
            existingValue: MSHW_0
            newValue: ""
          # Remove MSHW_ for non 0 values
          - type: replace
            column: 6
            existingValue: MSHW_
            newValue: ""
          - type: replace
            column: 7
            existingValue: MSHW_
            newValue: ""
            # Add a Sensor Type Column
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical,(SensorType)
          - type: rightConcat
            column: 7
            value: ;
        source(2):
          # Source(2) Discrete Thermal Table
          # Caption,DeviceID,HealthState,SensorType
          type: wbem
          query: "SELECT Caption,DeviceID,HealthState,SensorType FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with sensor type 2 (Thermal)
            # Caption,DeviceID,HealthState,SensorType
          - type: keepOnlyMatchingLines
            column: 3
            valueList: 2
            # Keep only lines with a valid HealthState
            # Caption,DeviceID,HealthState,SensorType
          - type: keepOnlyMatchingLines
            column: 2
            valueList: "5,15,20,25,30"
            # Need to add a bunch of columns so the dicrete and numerical tables will matchup
            # Add BaseUnits
            # (BaseUnits),Caption,DeviceID,HealthState,SensorType
          - type: leftConcat
            column: 1
            value: ;
            # Add CurrentReading,DeviceID
            # (BaseUnits),Caption,(CurrentReading),DeviceID,HealthState,SensorType
          - type: leftConcat
            column: 3
            value: ;
            # Add UpperThresholdNonCritical,UpperThresholdCritical
            # (BaseUnits),Caption,(CurrentReading),DeviceID,HealthState,(UpperThresholdNonCritical),(UpperThresholdCritical),SensorType
          - type: leftConcat
            column: 6
            value: ;;
        source(3):
          # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical, SensorType
          type: tableUnion
          tables:
          - "${source::monitors.temperature.discovery.sources.source(1)}"
          - "${source::monitors.temperature.discovery.sources.source(2)}"
          computes:
          # MSHW;BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical, SensorType
          - type: awk
            script: "${file::embeddedFile-3}"
          - type: keepOnlyMatchingLines
            column: 1
            valueList: MSHW
      mapping:
        # InstanceTable = Source(1)
        #          1        2         3        #   4        #    5        #         #    6        #     7
        # MSHW;BaseUnits,Caption,CurrentReading,DeviceID,HealthState,UpperThresholdNonCritical,UpperThresholdCritical, SensorType
        source: "${source::monitors.temperature.discovery.sources.source(3)}"
        attributes:
          __display_id: $3
          id: $5
          hw.parent.type: enclosure
          name: $3
        metrics:
          hw.temperature.limit{limit_type="high.critical"}: $8
          hw.temperature.limit{limit_type="high.degraded"}: $7
    collect:
      type: multiInstance
      sources:
        source(1):
          # BaseUnits,DeviceID,CurrentReading,HealthState
          # Note - Both RPM and Percent Temperature speeds are in Current Reading.
          type: wbem
          query: "SELECT BaseUnits,DeviceID,CurrentReading,HealthState FROM CIM_NumericSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 2 (Degree C)
            # BaseUnits,DeviceID,CurrentReading,HealthState
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 2
            # Divide Speed by 100
            # BaseUnits,DeviceID,CurrentReading,HealthState
          - type: divide
            column: 3
            value: 100
        source(2):
          # Source(2) Discrete Thermal Table
          # SensorType,DeviceID,HealthState
          type: wbem
          query: "SELECT SensorType,DeviceID,HealthState FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 2 (Thermal)
            # SensorType,DeviceID,HealthState
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 2
            # Add a CurrentReading Column
            # SensorType,DeviceID,CurrentReading,HealthState
          - type: leftConcat
            column: 3
            value: ;
        source(3):
          # BaseUnits,DeviceID,CurrentReading,HealthState,HealthState
          type: tableUnion
          tables:
          - "${source::monitors.temperature.collect.sources.source(1)}"
          - "${source::monitors.temperature.collect.sources.source(2)}"
          computes:
          # BaseUnits,DeviceID,CurrentReading,HealthState,HealthState
          - type: duplicateColumn
            column: 4
          # BaseUnits,DeviceID,CurrentReading,PatrolStatus,HealthState
          - type: translate
            column: 4
            translationTable: "${translation::statusTranslationTable}"
          # BaseUnits,DeviceID,CurrentReading,PatrolStatus,StatusInformation
          - type: translate
            column: 5
            translationTable: "${translation::statusInformationTranslationTable}"
      mapping:
        # Value Table
        # BaseUnits,DeviceID,CurrentReading,PatrolStatus,StatusInformation
        source: "${source::monitors.temperature.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="temperature"}: $4
          hw.temperature: $3
        legacyTextParameters:
          StatusInformation: $5
  fan:
    discovery:
      sources:
        source(1):
          # BaseUnits,Caption,CurrentReading,DeviceID,FanSpeedThreshold
          # Note - Both RPM and Percent Fan speeds are in Current Reading.
          type: wbem
          query: "SELECT BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical FROM CIM_NumericSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 19 (RPM)
            # BaseUnits,Caption,Speed,DeviceID,HealthState,FanSpeedThreshold
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 19
            # Divide Threshold by 100
            # BaseUnits,Caption,Speed,DeviceID,HealthState,FanSpeedThreshold
          - type: divide
            column: 6
            value: 100
            # Add an empty FanPercent column
            # BaseUnits,Caption,(FanPercent),Speed,DeviceID,HealthState,FanSpeedThreshold
          - type: leftConcat
            column: 3
            value: ;
            # Add an empty FanPercent Threshold column
            # BaseUnits,Caption,(FanPercent),Speed,DeviceID,HealthState,FanPercentThreshold,FanSpeedThreshold
          - type: leftConcat
            column: 7
            value: ;
        source(2):
          # BaseUnits,Caption,CurrentReading,DeviceID,FanPercentThreshold
          # Note - Both RPM and Percent Fan speeds are in Current Reading.
          type: wbem
          query: "SELECT BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,SensorType FROM CIM_NumericSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 65 (Percentage)
            # BaseUnits,Caption,FanPercent,DeviceID,HealthState,FanPercentThreshold,SensorType
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 65
            # Keep only lines with sensor type of 4 (Fan)
            # BaseUnits,Caption,FanPercent,DeviceID,HealthState,FanPercentThreshold,SensorType
          - type: keepOnlyMatchingLines
            column: 7
            valueList: 5
            # Remove the IPMISensorType
            # BaseUnits,Caption,FanPercent,DeviceID,HealthState,FanPercentThreshold,SensorType
          - type: keepColumns
            columnNumbers: "1,2,3,4,5,6"
            # Divide Threshold by 100
            # BaseUnits,Caption,FanPercent,DeviceID,HealthState,FanPercentThreshold
          - type: divide
            column: 6
            value: 100
            # Add an empty Speed column
            # BaseUnits,Caption,FanPercent,(Speed),DeviceID,HealthState,FanPercentThreshold
          - type: rightConcat
            column: 3
            value: ;
            # Add an empty FanSpeedThreshold
            # BaseUnits,Caption,FanPercent,(Speed),DeviceID,HealthState,FanPercentThreshold,(FanSpeedThreshold)
          - type: rightConcat
            column: 7
            value: ;
        source(3):
          # BaseUnits,Caption,FanPercent,Speed,DeviceID,HealthState,FanPercentThreshold,FanSpeedThreshold
          type: tableUnion
          tables:
          - "${source::monitors.fan.discovery.sources.source(1)}"
          - "${source::monitors.fan.discovery.sources.source(2)}"
          computes:
            # Remove Status of Unknown
            # BaseUnits,Caption,FanPercent,Speed,DeviceID,HealthState,FanPercentThreshold,FanSpeedThreshold
          - type: replace
            column: 6
            existingValue: 0
            newValue: ""
            # Duplicate the Healthstate so that we can use it to activate/deactivate numeric sensors.
            # BaseUnits,Caption,FanPercent,Speed,DeviceID,HealthState,NumericActivation,FanPercentThreshold,FanSpeedThreshold
          - type: duplicateColumn
            column: 6
          - type: leftConcat
            column: 7
            value: MSHW
          - type: rightConcat
            column: 7
            value: MSHW
          # Change MSHWMSHW to Activate as there is no valid HealthState
          - type: replace
            column: 7
            existingValue: MSHWMSHW
            newValue: Activate
          # Remove MSHW
          - type: replace
            column: 7
            existingValue: MSHW
            newValue: ""
          # Remove The original Healthstate so that the activation is blank for sensors with valid HealthStates
          - type: replace
            column: 7
            existingValue: $6
            newValue: ""
            # Ok, now we know if there is no valid healthstate and that we should activate speed / speedpercent.
            # Duplicate Speed
            # BaseUnits,Caption,FanPercent,SpeedActivation,Speed,DeviceID,HealthState,NumericActivation,FanPercentThreshold,FanSpeedThreshold
          - type: duplicateColumn
            column: 4
            # Speed - Add Activation column to left and right, then remove ActivateActivate
            # BaseUnits,Caption,FanPercent,SpeedActivation,Speed,DeviceID,HealthState,NumericActivation,FanPercentThreshold,FanSpeedThreshold
          - type: leftConcat
            column: 4
            value: $8
          - type: rightConcat
            column: 4
            value: $8
          - type: replace
            column: 4
            existingValue: ActivateActivate
            newValue: ""
          # Now remove the original value
          - type: replace
            column: 4
            existingValue: $5
            newValue: ""
            # Duplicate Speed
            # BaseUnits,Caption,FanPercent,SpeedActivation,Speed,DeviceID,HealthState,NumericActivation,FanPercentThreshold,FanSpeedThreshold
          - type: duplicateColumn
            column: 3
            # Speed - Add Activation column to left and right, then remove ActivateActivate
            # BaseUnits,Caption,FanPercentActivation,FanPercent,SpeedActivation,Speed,DeviceID,HealthState,NumericActivation,FanPercentThreshold,FanSpeedThreshold
          - type: leftConcat
            column: 3
            value: $9
          - type: rightConcat
            column: 3
            value: $9
          - type: replace
            column: 3
            existingValue: ActivateActivate
            newValue: ""
          # Now remove the original value
          - type: replace
            column: 3
            existingValue: $4
            newValue: ""
      mapping:
        # InstanceTable = Source(3)
        #    1        2        #         #   3        4        #  5        # 6        7        #  8        #  9        #          10        #       11
        # BaseUnits,Caption,FanPercentActivation,FanPercent,SpeedActivation,Speed,DeviceID,HealthState,NumericActivation,FanPercentThreshold,FanSpeedThreshold
        source: "${source::monitors.fan.discovery.sources.source(3)}"
        attributes:
          id: $7
          __display_id: $2
          hw.parent.type: enclosure
          name: $2
        metrics:
          hw.fan.speed.limit{limit_type="low.critical"}: $11
          hw.fan.speed_ratio.limit{limit_type="low.critical"}: percent2Ratio($10)
    collect:
      type: multiInstance
      sources:
        source(1):
          # BaseUnits,DeviceID,CurrentReading,DeviceID,FanSpeedThreshold
          # Note - Both RPM and Percent Fan speeds are in Current Reading.
          type: wbem
          query: "SELECT BaseUnits,DeviceID,CurrentReading,HealthState FROM CIM_NumericSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 19 (RPM)
            # BaseUnits,DeviceID,Speed,HealthStatus
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 19
            # Divide Speed by 100
            # BaseUnits,DeviceID,Speed,HealthStatus
          - type: divide
            column: 3
            value: 100
            # Add an empty FanPercent column
            # BaseUnits,DeviceID,(FanPercent),Speed,HealthStatus
          - type: leftConcat
            column: 3
            value: ;
        source(2):
          # BaseUnits,DeviceID,CurrentReading,HealthStatus
          # Note - Both RPM and Percent Fan speeds are in Current Reading.
          type: wbem
          query: "SELECT BaseUnits,DeviceID,CurrentReading,HealthState FROM CIM_NumericSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 65 (Percentage)
            # BaseUnits,DeviceID,FanPercent,HealthStatus
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 65
            # Divide FanPercent by 100
            # BaseUnits,DeviceID,FanPercent,HealthStatus
          - type: divide
            column: 3
            value: 100
            # Add an empty Speed column
            # BaseUnits,DeviceID,FanPercent,(Speed),HealthStatus
          - type: rightConcat
            column: 3
            value: ;
        source(3):
          # BaseUnits,DeviceID,FanPercent,Speed,HealthStatus
          type: tableUnion
          tables:
          - "${source::monitors.fan.collect.sources.source(1)}"
          - "${source::monitors.fan.collect.sources.source(2)}"
          computes:
          # BaseUnits,DeviceID,FanPercent,Speed,HealthStatus
          - type: duplicateColumn
            column: 5
          # BaseUnits,DeviceID,FanPercent,Speed,PatrolStatus,HealthStatus
          - type: translate
            column: 5
            translationTable: "${translation::statusTranslationTable}"
          # BaseUnits,DeviceID,FanPercent,Speed,PatrolStatus,StatusInformation
          - type: translate
            column: 6
            translationTable: "${translation::statusInformationTranslationTable}"
      mapping:
        # Value Table
        # BaseUnits,DeviceID,FanPercent,Speed,PatrolStatus,StatusInformation
        source: "${source::monitors.fan.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="fan"}: $5
          hw.fan.speed: $4
          hw.fan.speed_ratio: percent2Ratio($3)
        legacyTextParameters:
          StatusInformation: $6
  voltage:
    discovery:
      sources:
        source(1):
          # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical
          type: wbem
          query: "SELECT BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical FROM CIM_NumericSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 5 (Volts)
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 5
            # Multiply by 10 to get millivolts (Divide Thresholds by 100, then Multiply by 1000)
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical
          - type: multiply
            column: 6
            value: 10
          - type: multiply
            column: 7
            value: 10
            # Remove Status of Unknown
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical
          - type: replace
            column: 5
            existingValue: 0
            newValue: ""
            # Thresholds for Voltage are sometimes reported as "0" by the agent.  Replacing these "0" by no value to prevent incorrect thresholds.
            # Add a MSHW_ string to our value and then remove MSHW_0. This should remove a 0 value and only that value
            # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical
          - type: leftConcat
            column: 6
            value: MSHW_
          - type: leftConcat
            column: 7
            value: MSHW_
          # Remove 0 value
          - type: replace
            column: 6
            existingValue: MSHW_0
            newValue: ""
          - type: replace
            column: 7
            existingValue: MSHW_0
            newValue: ""
          # Remove MSHW_ for non 0 values
          - type: replace
            column: 6
            existingValue: MSHW_
            newValue: ""
          - type: replace
            column: 7
            existingValue: MSHW_
            newValue: ""
        source(2):
          # Source(2) Discrete Voltage Table
          # SensorType,Caption,DeviceID,HealthState
          type: wbem
          query: "SELECT SensorType,Caption,DeviceID,HealthState FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with sensor type 3 (Voltage)
            # SensorType,Caption,DeviceID,HealthState
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 3
            # Keep only lines with a valid HealthState
            # SensorType,Caption,DeviceID,HealthState
          - type: keepOnlyMatchingLines
            column: 4
            valueList: "5,15,20,25,30"
            # Add columns CurrentReading to the left of Device ID
            # and LowerThresholdCritical,UpperThresholdCritical to the right
            # SensorType,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical
          - type: rightConcat
            column: 4
            value: ;;
          - type: leftConcat
            column: 3
            value: ;
        source(3):
          # SensorType,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical
          type: tableUnion
          tables:
          - "${source::monitors.voltage.discovery.sources.source(1)}"
          - "${source::monitors.voltage.discovery.sources.source(2)}"
      mapping:
        # InstanceTable = Source(1)
        #    1        2         3        #   4        #    5        #         #    6        #     7
        # BaseUnits,Caption,CurrentReading,DeviceID,HealthState,LowerThresholdCritical,UpperThresholdCritical
        source: "${source::monitors.voltage.discovery.sources.source(3)}"
        attributes:
          id: $4
          __display_id: $2
          hw.parent.type: enclosure
          name: $2
        metrics:
          hw.voltage.limit{limit_type="high.degraded"}: $7
          hw.voltage.limit{limit_type="low.critical"}: $6
    collect:
      type: multiInstance
      sources:
        source(1):
          # BaseUnits,DeviceID,CurrentReading,HealthState
          type: wbem
          query: "SELECT BaseUnits,DeviceID,CurrentReading,HealthState FROM CIM_NumericSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 5 (Voltage)
            # BaseUnits,DeviceID,CurrentReading,HealthState
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 5
            # Multiply by 10 to get millivolts (Divide Thresholds by 100, then Multiply by 1000)
            # BaseUnits,DeviceID,CurrentReading,HealthState
          - type: multiply
            column: 3
            value: 10
        source(2):
          # Source(2) Discrete Thermal Table
          # SensorType,DeviceID,HealthState
          type: wbem
          query: "SELECT SensorType,DeviceID,HealthState FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with units of type 3 (Voltage)
            # SensorType,DeviceID,HealthState
          - type: keepOnlyMatchingLines
            column: 1
            valueList: 3
            # Add a CurrentReading Column
            # SensorType,DeviceID,CurrentReading,HealthState
          - type: leftConcat
            column: 3
            value: ;
        source(3):
          # BaseUnits,DeviceID,CurrentReading,HealthState,HealthState
          type: tableUnion
          tables:
          - "${source::monitors.voltage.collect.sources.source(1)}"
          - "${source::monitors.voltage.collect.sources.source(2)}"
          computes:
          # BaseUnits,DeviceID,CurrentReading,HealthState,HealthState
          - type: duplicateColumn
            column: 4
          # BaseUnits,DeviceID,CurrentReading,PatrolStatus,HealthState
          - type: translate
            column: 4
            translationTable: "${translation::statusTranslationTable}"
          # BaseUnits,DeviceID,CurrentReading,PatrolStatus,StatusInformation
          - type: translate
            column: 5
            translationTable: "${translation::statusInformationTranslationTable}"
      mapping:
        # Value Table
        # BaseUnits,DeviceID,CurrentReading,PatrolStatus,StatusInformation
        source: "${source::monitors.voltage.collect.sources.source(3)}"
        deviceId: $2
        metrics:
          hw.status{hw.type="voltage"}: $4
          hw.voltage: $3
        legacyTextParameters:
          StatusInformation: $5
  network:
    discovery:
      sources:
        source(1):
          # Source(1) = CIM_NetworkPort
          # DeviceID;PortTypeCode;Speed;PermanentAddress;EnabledState;
          type: wbem
          query: "SELECT DeviceID,PortType,Speed,PermanentAddress,EnabledState,FullDuplex FROM CIM_NetworkPort"
          namespace: root/cimv2
          computes:
            # Keep only activated ports
            # DeviceID;PortTypeCode;Speed;PermanentAddress;EnabledState;FullDuplex
          - type: excludeMatchingLines
            column: 5
            valueList: 3
            # Translate PortType into a more readable string
            # DeviceID;PortType;Speed;PermanentAddress;EnabledState;FullDuplex
          - type: translate
            column: 2
            translationTable: "${translation::PortTypeTranslationTable}"
            # Convert Speed from bps to Mbps (divide by 1000000)
            # DeviceID;PortType;SpeedMbps;PermanentAddress;EnabledState;FullDuplex
          - type: divide
            column: 3
            value: 1000000
            # Translate Full Duplex boolean from string to int
            # Translate PortType into a more readable string
            # DeviceID;PortType;Speed;PermanentAddress;EnabledState;FullDuplex
          - type: translate
            column: 6
            translationTable: "${translation::DuplexTypeTranslationTable}"
      mapping:
        # InstanceTable = Source(7)
        # DeviceID;PortType;SpeedMbps;PermanentAddress;EnabledState;FullDuplex
        source: "${source::monitors.network.discovery.sources.source(1)}"
        attributes:
          id: $1
          physical_address: $4
          physical_address_type: MAC
          device_type: $2
          hw.parent.type: enclosure
          name: "${awk::sprintf(\"%s (%s)\", $1, $2)}"
    collect:
      # The NetworkCard collect is a "MultiInstance" collect
      type: multiInstance
      sources:
        source(1):
          # Source(1) = CIM_FCPort
          # PortID;PortTypeCode;EnabledState;Speed;OperationalStatusArray
          type: wbem
          query: "SELECT DeviceID,PortType,EnabledState,Speed,OperationalStatus,FullDuplex FROM CIM_NetworkPort"
          namespace: root/cimv2
          computes:
            # Duplicate the "OperationalStatusArray" column
            # PortID;PortTypeCode;EnabledState;Speed;OperationalStatusArray;OperationalStatusArray;FullDuplex
          - type: duplicateColumn
            column: 5
            # Then we translate DMTF's OperationStatus code into OK/WARN/ALARM (for the Status parameter)
            # PortID;PortTypeCode;EnabledState;Speed;PATROLStatusArray;Status;FullDuplex
          - type: arrayTranslate
            column: 5
            translationTable: "${translation::NetworkCardOperationStatusTranslationTable}"
            # And finally, we translate DMTF's OperationalStatus code into a more readable status string
            # PortID;PortTypeCode;EnabledState;Speed;PATROLStatusArray;StatusInformation;FullDuplex
          - type: arrayTranslate
            column: 6
            translationTable: "${translation::DMTFOperationStatusInformationTranslationTable}"
            resultSeparator: ' - '
            # Convert PATROLStatusArray to a simple (unique) PATROLStatus
            # PortID;PortTypeCode;EnabledState;Speed;PATROLStatus;StatusInformation;FullDuplex
          - type: convert
            column: 5
            conversion: array2SimpleStatus
            # // Finally, we check whether we have a 'Speed' number, meaning that the link is up
            # PortID;PortTypeCode;EnabledState;Speed;LinkStatus;PATROLStatusArray;Status;FullDuplex
          - type: duplicateColumn
            column: 4
            # Finally, we check whether we have a 'Speed' number, meaning that the link is up
            # Otherwise, if no speed, it means that the link is down
            # PortID;PortTypeCode;EnabledState;Speed;LinkStatus;PATROLStatusArray;Status;FullDuplex
          - type: translate
            column: 5
            translationTable: "${translation::SpeedToLinkStatusTranslationTable}"
            # Translate Full Duplex boolean from string to int
            # Translate PortType into a more readable string
            # PortID;PortTypeCode;EnabledState;Speed;LinkStatus;PATROLStatusArray;Status;FullDuplex
          - type: translate
            column: 8
            translationTable: "${translation::DuplexTypeTranslationTable}"
            # Convert Speed from bps to Mbps (divide by 1000000)
            # PortID;PortTypeCode;EnabledState;Speed;LinkStatus;PATROLStatusArray;Status;FullDuplex
          - type: divide
            column: 4
            value: 1000000
      mapping:
        # PortID;PortTypeCode;EnabledState;Speed;LinkStatus;PATROLStatusArray;Status
        # ValueTable = Source(1)
        source: "${source::monitors.network.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="network"}: $6
          hw.network.bandwidth.limit: megaBit2Bit($4)
          hw.network.up: legacyLinkStatus($5)
          hw.network.full_duplex: legacyFullDuplex($8)
        legacyTextParameters:
          StatusInformation: $7
  battery:
    discovery:
      sources:
        source(1):
          # DeviceID,HealthState,IpmiSensorType,Caption,deviceID
          type: wbem
          query: "SELECT MonitoredDeviceID,HealthState,IpmiSensorType,Caption,DeviceId FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with a valid HealthState
            # DeviceID,HealthState,IpmiSensorType,Caption,deviceID
          - type: keepOnlyMatchingLines
            column: 3
            valueList: 41
            # Process the discrete sensors to group sensors together and find a common name
            # DeviceID,DisplayID
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,3"
      mapping:
        # InstanceTable = Source(1)
        # DeviceID,DisplayID
        source: "${source::monitors.battery.discovery.sources.source(1)}"
        attributes:
          id: $1
          __display_id: $2
          hw.parent.type: enclosure
          name: $2
    collect:
      type: multiInstance
      sources:
        source(1):
          # DeviceID,HealthState,IpmiSensorType,Caption,deviceID
          type: wbem
          query: "SELECT MonitoredDeviceID,HealthState,IpmiSensorType,Caption,DeviceId FROM OMC_DiscreteSensor"
          namespace: root/cimv2
          computes:
            # Keep only lines with a valid HealthState
            # DeviceID,HealthState,IpmiSensorType,Caption,deviceID
          - type: keepOnlyMatchingLines
            column: 3
            valueList: 41
            # Process the discrete sensors to group sensors together and find a common name
            # DeviceID,PatrolStatus,StatusInformation
          - type: awk
            script: "${file::embeddedFile-4}"
            keep: ^MSHW;
            separators: ;
            selectColumns: "2,4,5"
          # DeviceID,PatrolStatus,StatusInformation
          - type: translate
            column: 2
            translationTable: "${translation::statusTranslationTable}"
      mapping:
        # Instance Table
        # DeviceID,PatrolStatus,StatusInformation
        source: "${source::monitors.battery.collect.sources.source(1)}"
        deviceId: $1
        metrics:
          hw.status{hw.type="battery"}: $2
        legacyTextParameters:
          StatusInformation: $3
translations:
  psuAvailabilityTranslationTable:
    "11": MISSING
    "12": failed
    "13": UNKNOWN
    "14": degraded
    "15": ok
    "16": ok
    "17": degraded
    "18": ok
    "19": failed
    Default: UNKNOWN
    "1": MISSING
    "2": MISSING
    "3": ok
    "4": degraded
    "5": degraded
    "6": MISSING
    "7": failed
    "8": failed
    "9": ok
    "20": degraded
    "10": degraded
    "21": ok
  statusInformationTranslationTable:
    "0": Unknown
    "25": Critical Failure
    "15": Minor Failure
    "5": ""
    "30": Non-Recoverable Error
    Default: Unknown Status
    "20": Major Failure
    "10": Degraded
  statusTranslationTable:
    "0": UNKNOWN
    "25": failed
    "15": degraded
    "5": ok
    "30": failed
    Default: UNKNOWN
    "20": failed
    "10": degraded
  psuAvailabilityInformationTranslationTable:
    "11": Not Installed
    "12": Install Error
    "13": Power Save - Unknown
    "14": Power Save - Lower Power Mode
    "15": Power Save - Standy
    "16": Power Cycle
    "17": Power Save - Warning
    "18": Paused
    "19": Not Ready
    Default: Unknown Status
    "1": Other / Unknown
    "2": Unknown
    "3": ""
    "4": Warning
    "5": In Test
    "6": Not Applicable
    "7": Power Off
    "8": Off Line
    "9": Off Duty
    "20": Not Configured
    "10": Degraded
    "21": Quiesced
  PortTypeTranslationTable:
    "11": HBA FC Port NL (Node/Loop)
    "55": Ethernet Port
    "12": HBA FC Port F/NL (Node/Loop/Fabric)
    "56": Ethernet Port
    Default: Unknown Network Port Type
    "0": Unknown Network Port Type
    "110": Ethernet Port
    "1": Other Network Port Type
    "100": Ethernet Port
    "101": Ethernet Port
    "102": Ethernet Port
    "103": Ethernet Port
    "104": Ethernet Port
    "105": Ethernet Port
    "106": Ethernet Port
    "107": Ethernet Port
    "108": Ethernet Port
    "109": Ethernet Port
    "50": Ethernet Port
    "51": Ethernet Port
    "52": Ethernet Port
    "53": Ethernet Port
    "10": HBA FC Port N (Node)
    "54": Ethernet Port
  DuplexTypeTranslationTable:
    "false": 0
    Default: 1
  NetworkCardOperationStatusTranslationTable:
    "11": degraded
    "12": failed
    "13": failed
    "14": failed
    "15": degraded
    "16": degraded
    "17": ok
    "18": ok
    Default: UNKNOWN
    "2": ok
    "3": degraded
    "4": degraded
    "5": degraded
    "6": failed
    "7": failed
    "8": degraded
    "9": degraded
    "10": ok
  DMTFOperationStatusInformationTranslationTable:
    "11": In Service
    "12": No Contact
    "13": Lost Communication
    "14": Aborted
    "15": Dormant
    "16": Supporting Entity in Error
    "17": Completed
    "18": Power Mode
    Default: Unknown Status
    "2": ""
    "3": Degraded
    "4": Stressed
    "5": Predicted Failure
    "6": Error
    "7": Non-Recoverable Error
    "8": Starting
    "9": Stopping
    "10": Stopped
  SpeedToLinkStatusTranslationTable:
    "0": degraded
    ? ""
    : degraded
    Default: ok
